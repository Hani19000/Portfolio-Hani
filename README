1️⃣Présentation du projet
Pourquoi j'ai lancé ce projet
J'ai créé ce portfolio pour avoir une vitrine professionnelle qui me ressemble vraiment. Je voulais un espace où je pouvais présenter mon parcours, mes compétences techniques et mes projets de manière élégante et fonctionnelle. C'était aussi l'occasion de montrer concrètement ce que je sais faire en développement web.
Le problème que je voulais résoudre
Avant ce projet, je n'avais pas de plateforme centralisée pour présenter mon travail. Je voulais un site qui :

Reflète mon identité professionnelle
Permette aux recruteurs et clients potentiels de me contacter facilement
Démontre mes capacités techniques de manière tangible
Soit entièrement conçu et développé par moi-même

Le contexte
C'est un projet personnel que j'ai construit dans le cadre de ma formation en développement web full-stack. Il me sert à la fois de portfolio professionnel et de terrain d'expérimentation pour appliquer les concepts que j'apprends. C'est un projet vivant que je continue d'améliorer au fil de mes nouvelles compétences.
À qui s'adresse le projet
Ce portfolio s'adresse principalement aux recruteurs, entreprises et clients potentiels qui veulent découvrir mon profil et mes réalisations. Il est également utile pour d'autres développeurs qui souhaitent voir comment j'organise et structure mes projets.

2️⃣ Fiche technique complète
Nom du projet
Portfolio Hani Derrouiche - Site vitrine personnel et professionnel
Description fonctionnelle
J'ai développé un portfolio moderne et interactif qui présente mon parcours, mes compétences techniques, mes services, et mes projets. Le site inclut un formulaire de contact fonctionnel qui permet aux visiteurs de m'envoyer directement un message.
Fonctionnalités principales
Frontend :

Navigation fluide avec indicateur de section active
Thème dark/light mode avec persistance de la préférence
Carrousel de projets interactif (Swiper)
Formulaire de contact avec validation et feedback visuel
Timeline de parcours (formation et expérience)
Animations et particules pour un effet moderne
Design responsive optimisé mobile/tablette/desktop
Lazy loading des sections pour optimiser les performances
Indicateur de statut du serveur backend en temps réel

Backend :

API REST pour gérer l'envoi d'emails via SendGrid
Validation et sanitisation des données (validator.js)
Rate limiting anti-spam (2 messages/heure)
Gestion des erreurs centralisée
Monitoring avec Sentry
Health check endpoint (/api/ping)

Stack technique
Front-end :

React 19 avec TypeScript
Vite comme bundler
CSS custom (pas de framework CSS)
Swiper.js pour le carrousel
React Icons
Sentry pour le monitoring frontend

Back-end :

Node.js avec Express
TypeScript
SendGrid pour l'envoi d'emails
Validator.js pour la sanitisation
Express-rate-limit pour le rate limiting

Sécurité & Infrastructure :

Helmet.js (headers HTTP sécurisés)
CORS configuré
Compression des réponses
Sentry pour le monitoring serveur

Outils & Services :

GitHub Actions pour la CI/CD
Vercel pour l'hébergement frontend
Render pour le backend (probablement)
ESLint & Prettier pour la qualité du code
TypeScript pour le typage strict

Architecture du projet
Structure frontend (/frontend) :
src/
├── api/              # Logique d'appel à l'API
├── components/       # Composants réutilisables par section
├── Data/             # Données structurées (projets, services, etc.)
├── hooks/            # Custom hooks (email, navigation, thème)
├── pages/            # Sections principales du site
├── styles/           # CSS modulaire par section
└── utils/            # Fonctions utilitaires (validation, erreurs)
Structure backend (/backend) :
backend/
├── config/           # Configuration (email, sécurité)
├── middleware/       # Rate limiting, validation
├── routes/           # Routes Express
├── utils/            # Logger personnalisé
└── server.ts         # Point d'entrée
Logique globale :

Architecture découplée : le frontend appelle le backend via une API REST
Séparation claire des responsabilités
Composants React modulaires et réutilisables
Gestion d'état locale avec hooks (pas de Redux, ce qui est adapté à la taille du projet)
Données statiques centralisées dans /Data

Choix techniques et justifications
Pourquoi React + TypeScript ?
J'ai choisi React car c'est la bibliothèque que je maîtrise le mieux et qui est très demandée sur le marché. TypeScript m'apporte la sécurité du typage et réduit considérablement les bugs.
Pourquoi Vite ?
Vite offre un temps de build ultra-rapide et un hot reload instantané en développement. C'est devenu mon outil préféré pour les projets React modernes.
Pourquoi pas de framework CSS ?
J'ai voulu démontrer ma maîtrise du CSS pur. Cela me donne aussi un contrôle total sur le design et évite d'alourdir le bundle avec des styles inutilisés.
Pourquoi SendGrid ?
C'est une solution fiable et bien documentée pour l'envoi d'emails. Elle offre un tier gratuit suffisant pour un portfolio et une excellente délivrabilité.
Pourquoi le rate limiting ?
Pour protéger mon API contre le spam et les abus. C'est une bonne pratique que j'ai intégrée dès le départ.
Sécurité
Validation des données :

Validation côté frontend ET backend
Sanitisation avec validator.js (protection XSS)
Vérification des formats d'email
Limites de taille pour les champs texte

Protection API :

CORS configuré avec liste blanche d'origines
Helmet.js pour sécuriser les headers HTTP
Rate limiting (2 requêtes/heure par IP)
Compression des réponses
Gestion centralisée des erreurs

Monitoring :

Sentry configuré en frontend et backend
Capture automatique des erreurs
Logs structurés avec un logger personnalisé

Performance et optimisation
Frontend :

Lazy loading des sections avec React.lazy()
Images optimisées en WebP
Code splitting automatique avec Vite
Vendor chunks séparés (React, Swiper, Icons, Sentry)
Préchargement des polices Google Fonts
Minification avec Terser en production
Suppression des console.log en production

Backend :

Compression gzip des réponses
Trust proxy configuré pour Vercel/Render
Réponses JSON légères
Health check pour éviter le cold start

Infrastructure :

Cache-Control headers pour les assets statiques
CDN via Vercel
Workflow CI/CD optimisé (lint → build → deploy)

Qualité du code
Lisibilité :

Nommage explicite des variables et fonctions
Commentaires pertinents en français (mon choix pour ce projet)
Découpage en petits composants réutilisables
Séparation logique/présentation claire

Modularité :

Composants React découplés et autonomes
Hooks personnalisés pour la logique complexe
Données centralisées dans /Data
Styles modulaires par composant

Typage :

TypeScript strict activé
Interfaces définies pour toutes les structures de données
Props typées pour tous les composants
Aucun any (sauf gestion d'erreurs génériques)

Organisation :

Structure de dossiers claire et cohérente
Séparation frontend/backend nette
Configuration centralisée (.env, tsconfig, vite.config)

Tests
Ce qui est en place :

Validation manuelle extensive
Tests d'intégration manuels du formulaire de contact
Monitoring en production avec Sentry

Ce que je prévois d'ajouter :

Tests unitaires avec Vitest pour les fonctions utilitaires
Tests de composants avec React Testing Library
Tests E2E avec Playwright pour les parcours critiques
Tests d'API avec Supertest

Points forts du projet

Architecture propre : Séparation claire frontend/backend avec API REST
TypeScript full-stack : Typage strict partout pour plus de robustesse
Sécurité pensée dès le départ : Validation, sanitisation, rate limiting, CORS
Performance optimisée : Lazy loading, code splitting, images WebP
CI/CD fonctionnel : Pipeline automatisé avec GitHub Actions
Monitoring en production : Sentry configuré pour détecter les problèmes rapidement
UX soignée : Dark/light mode, animations fluides, design responsive
Code maintenable : Composants réutilisables, hooks personnalisés, structure modulaire

Axes d'amélioration

Tests automatisés : Ajouter une suite de tests complète
Accessibilité : Audit et amélioration WCAG (contrastes, navigation clavier, ARIA)
Internationalisation : Support multilingue (français/anglais)
SEO avancé : Meta tags dynamiques, schema.org
Analytics : Intégrer Google Analytics ou une alternative respectueuse de la vie privée
Backend plus robuste : Passer sur NestJS ou Fastify pour une meilleure structure
Database : Stocker les messages de contact dans une base de données
Admin panel : Interface pour gérer les contenus sans toucher au code


3️⃣ Timeline du projet
Phase 1 – Idéation & cadrage (Semaine 1)
Ce que j'ai fait :

Défini les objectifs : portfolio professionnel avec formulaire de contact
Esquissé les sections principales (Header, About, Experience, Services, Portfolio, Contact)
Créé une maquette Figma simple pour le design
Choisi la stack : React + TypeScript + Express + SendGrid

Ce que j'ai appris :

L'importance de bien cadrer un projet avant de coder
Comment structurer un portfolio efficace

Difficultés rencontrées :

Trouver un design qui me ressemble et qui soit professionnel sans être terne

Phase 2 – Conception (Semaine 1-2)
Ce que j'ai fait :

Défini l'architecture frontend/backend
Modélisé les données (interfaces TypeScript)
Créé la structure de dossiers
Configuré les outils (ESLint, Prettier, TypeScript)

Ce que j'ai appris :

L'architecture d'un projet full-stack moderne
Les bonnes pratiques de configuration TypeScript

Difficultés rencontrées :

Organiser proprement les types partagés entre frontend et backend

Phase 3 – Développement (Semaines 2-5)
Frontend :

Semaine 2 : Mise en place du Header, Navigation, et structure de base
Semaine 3 : Développement des sections About, Experience, Services
Semaine 4 : Carrousel Portfolio avec Swiper, section Contact
Semaine 5 : Dark/light mode, animations, particules, responsive design

Backend :

Semaine 3 : API Express de base avec endpoint /contact
Semaine 4 : Intégration SendGrid, validation, rate limiting
Semaine 5 : Monitoring Sentry, health check, gestion d'erreurs

Ce que j'ai appris :

La gestion avancée de l'état React avec des hooks personnalisés
Comment sécuriser une API REST de manière efficace
L'intégration de services tiers (SendGrid, Sentry)
Les techniques d'optimisation des performances (lazy loading, code splitting)

Difficultés rencontrées :

Gérer le CORS correctement entre frontend et backend
Implémenter un rate limiting fiable
Optimiser les images pour le web
Gérer l'état du thème avec persistance localStorage

Phase 4 – Tests & corrections (Semaine 6)
Ce que j'ai fait :

Tests manuels de tous les parcours utilisateurs
Débogage du formulaire de contact
Corrections de bugs CSS (responsive, thème)
Amélioration de l'UX (feedback visuel, transitions)

Ce que j'ai appris :

L'importance des tests utilisateurs réels
Comment déboguer efficacement avec les DevTools
Les pièges classiques du responsive design

Difficultés rencontrées :

Gérer l'affichage du carrousel Swiper de manière stable
Assurer la compatibilité navigateur (Safari notamment)

Phase 5 – Finalisation (Semaine 7)
Ce que j'ai fait :

Optimisations finales (images, bundle size, animations)
Configuration du CI/CD avec GitHub Actions
Déploiement sur Vercel (frontend) et Render (backend)
Ajout du sitemap et robots.txt pour le SEO
Rédaction de la documentation

Ce que j'ai appris :

Comment configurer un pipeline CI/CD complet
Les bonnes pratiques de déploiement en production
L'importance du monitoring en production

Difficultés rencontrées :

Gérer les variables d'environnement entre dev et production
Configurer correctement le CORS pour les URLs de production
Optimiser le cold start du backend sur Render


4️⃣ Ce que ce projet démontre sur mon profil
Compétences techniques
Frontend :

Maîtrise de React moderne (hooks, lazy loading, suspense)
Capacité à créer des interfaces complexes sans framework CSS
Connaissance des optimisations de performance web
Expérience avec TypeScript et les patterns de typage avancés

Backend :

Développement d'API REST sécurisées
Gestion de la sécurité (validation, sanitisation, rate limiting)
Intégration de services tiers (SendGrid, Sentry)
Monitoring et observabilité en production

DevOps :

Configuration de pipelines CI/CD (GitHub Actions)
Déploiement sur des plateformes cloud modernes (Vercel, Render)
Gestion des environnements (dev, staging, production)

Qualité & Bonnes pratiques :

Code propre et maintenable
Architecture modulaire et évolutive
Gestion d'erreurs robuste
Documentation technique claire

Capacité à structurer un projet de A à Z
Ce projet démontre que je sais :

Partir d'une idée et aller jusqu'au déploiement
Organiser un projet full-stack de manière cohérente
Faire des choix techniques justifiés
Anticiper les problèmes de sécurité et de performance
Livrer un produit fini et fonctionnel

Autonomie
J'ai réalisé ce projet entièrement seul :

Conception du design
Développement frontend et backend
Configuration de l'infrastructure
Déploiement et monitoring

Je sais chercher des solutions par moi-même et je comprends l'importance de la documentation.
Compréhension des bonnes pratiques modernes
Le projet reflète ma connaissance des standards actuels :

Typage strict avec TypeScript
Sécurité dès la conception
Performance et optimisation
Monitoring en production
CI/CD automatisé
Code splitting et lazy loading